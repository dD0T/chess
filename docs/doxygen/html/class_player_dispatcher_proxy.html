<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>3dchess: PlayerDispatcherProxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">3dchess
   </div>
   <div id="projectbrief">Basic chess application with OpenGL graphics and AI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_player_dispatcher_proxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PlayerDispatcherProxy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Proxy for transporting AbstractGamePlayer events between threads.  
 <a href="class_player_dispatcher_proxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_player_dispatcher_proxy_8h_source.html">PlayerDispatcherProxy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PlayerDispatcherProxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_player_dispatcher_proxy.png" usemap="#PlayerDispatcherProxy_map" alt=""/>
  <map id="PlayerDispatcherProxy_map" name="PlayerDispatcherProxy_map">
<area href="class_abstract_player.html" title="Class a player has to implement to interact with the GameLogic. Every player is also a AbstractGameOb..." alt="AbstractPlayer" shape="rect" coords="0,56,145,80"/>
<area href="class_service_dispatcher.html" title="Provides functionality for safely running operations in a thread. " alt="ServiceDispatcher" shape="rect" coords="155,56,300,80"/>
<area href="class_abstract_game_observer.html" title="Allows to observe relevant GameEvents inside the GameLogic. Classes of this type can be registered wi..." alt="AbstractGameObserver" shape="rect" coords="0,0,145,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e361c66e64afcf38bacc1187cb8ee9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e361c66e64afcf38bacc1187cb8ee9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PlayerDispatcherProxy</b> (AbstractPlayerPtr player)</td></tr>
<tr class="separator:a3e361c66e64afcf38bacc1187cb8ee9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69147934e21adbbcf49ac0759a5bcd16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a69147934e21adbbcf49ac0759a5bcd16">onSetColor</a> (PlayerColor color) override</td></tr>
<tr class="memdesc:a69147934e21adbbcf49ac0759a5bcd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies that player what color he will be playing. Called before onGameStart.  <a href="#a69147934e21adbbcf49ac0759a5bcd16">More...</a><br/></td></tr>
<tr class="separator:a69147934e21adbbcf49ac0759a5bcd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5c3e5d60e074a34570748b0b2a8b7"><td class="memItemLeft" align="right" valign="top">virtual std::future&lt; <a class="el" href="class_turn.html">Turn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a37c5c3e5d60e074a34570748b0b2a8b7">doMakeTurn</a> (<a class="el" href="class_game_state.html">GameState</a> state) override</td></tr>
<tr class="memdesc:a37c5c3e5d60e074a34570748b0b2a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the player to make his turn.  <a href="#a37c5c3e5d60e074a34570748b0b2a8b7">More...</a><br/></td></tr>
<tr class="separator:a37c5c3e5d60e074a34570748b0b2a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe09c22c7baba67628965bcef8d3a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83fe09c22c7baba67628965bcef8d3a0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a83fe09c22c7baba67628965bcef8d3a0">doAbortTurn</a> () override</td></tr>
<tr class="memdesc:a83fe09c22c7baba67628965bcef8d3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the player to abort a turn asked for with doMakeTurn. When this is called the <a class="el" href="class_game_logic.html" title="GameLogic implementation for a game of chess with observers. ">GameLogic</a> will no longer react to the completion of the future for that turn. A use of this function is the abortion of a turn due to timeout. <br/></td></tr>
<tr class="separator:a83fe09c22c7baba67628965bcef8d3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4331a5225da27c3519faf665a15618f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a4331a5225da27c3519faf665a15618f0">onGameStart</a> (<a class="el" href="class_game_state.html">GameState</a> state, <a class="el" href="class_game_configuration.html">GameConfiguration</a> config) override</td></tr>
<tr class="memdesc:a4331a5225da27c3519faf665a15618f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the game starts.  <a href="#a4331a5225da27c3519faf665a15618f0">More...</a><br/></td></tr>
<tr class="separator:a4331a5225da27c3519faf665a15618f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2da2b5609de70f20b44c1c8aacb1c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a8c2da2b5609de70f20b44c1c8aacb1c2">onTurnStart</a> (PlayerColor who) override</td></tr>
<tr class="memdesc:a8c2da2b5609de70f20b44c1c8aacb1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if a player is asked to perform a turn.  <a href="#a8c2da2b5609de70f20b44c1c8aacb1c2">More...</a><br/></td></tr>
<tr class="separator:a8c2da2b5609de70f20b44c1c8aacb1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad391616bbb56762ddb05460ce11f96ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#ad391616bbb56762ddb05460ce11f96ff">onTurnEnd</a> (PlayerColor who, <a class="el" href="class_turn.html">Turn</a> turn, <a class="el" href="class_game_state.html">GameState</a> newState) override</td></tr>
<tr class="memdesc:ad391616bbb56762ddb05460ce11f96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if a player ended its turn.  <a href="#ad391616bbb56762ddb05460ce11f96ff">More...</a><br/></td></tr>
<tr class="separator:ad391616bbb56762ddb05460ce11f96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9b69ba6adc27db4f08445fdacfdcb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#aec9b69ba6adc27db4f08445fdacfdcb1">onTurnTimeout</a> (PlayerColor who, std::chrono::seconds timeout) override</td></tr>
<tr class="memdesc:aec9b69ba6adc27db4f08445fdacfdcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if a players turn is aborted due to timeout.  <a href="#aec9b69ba6adc27db4f08445fdacfdcb1">More...</a><br/></td></tr>
<tr class="separator:aec9b69ba6adc27db4f08445fdacfdcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aae031f975e7c90fd80eb5e34540757"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_player_dispatcher_proxy.html#a4aae031f975e7c90fd80eb5e34540757">onGameOver</a> (<a class="el" href="class_game_state.html">GameState</a> state, PlayerColor winner) override</td></tr>
<tr class="memdesc:a4aae031f975e7c90fd80eb5e34540757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a game started with onGameStart is over.  <a href="#a4aae031f975e7c90fd80eb5e34540757">More...</a><br/></td></tr>
<tr class="separator:a4aae031f975e7c90fd80eb5e34540757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_service_dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_service_dispatcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_service_dispatcher.html">ServiceDispatcher</a></td></tr>
<tr class="memitem:a523e6f7dc4e533b0b7938cec62c55c6d inherit pub_methods_class_service_dispatcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#a523e6f7dc4e533b0b7938cec62c55c6d">poll</a> ()</td></tr>
<tr class="memdesc:a523e6f7dc4e533b0b7938cec62c55c6d inherit pub_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replays all posted functions in the calling thread.  <a href="#a523e6f7dc4e533b0b7938cec62c55c6d">More...</a><br/></td></tr>
<tr class="separator:a523e6f7dc4e533b0b7938cec62c55c6d inherit pub_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_service_dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_service_dispatcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_service_dispatcher.html">ServiceDispatcher</a></td></tr>
<tr class="memitem:a51360fc052cab5a9bad17fd586081091 inherit pro_methods_class_service_dispatcher"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a51360fc052cab5a9bad17fd586081091 inherit pro_methods_class_service_dispatcher"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#a51360fc052cab5a9bad17fd586081091">post</a> (Function &amp;&amp;function)</td></tr>
<tr class="memdesc:a51360fc052cab5a9bad17fd586081091 inherit pro_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a given function.  <a href="#a51360fc052cab5a9bad17fd586081091">More...</a><br/></td></tr>
<tr class="separator:a51360fc052cab5a9bad17fd586081091 inherit pro_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1723f2592299a9bf4ac9e9557929cf52 inherit pro_methods_class_service_dispatcher"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a1723f2592299a9bf4ac9e9557929cf52 inherit pro_methods_class_service_dispatcher"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#a1723f2592299a9bf4ac9e9557929cf52">postPromise</a> (Function &amp;&amp;function) -&gt; decltype(std::promise&lt; typename std::result_of&lt; Function()&gt;::type &gt;().get_future())</td></tr>
<tr class="memdesc:a1723f2592299a9bf4ac9e9557929cf52 inherit pro_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a given function and returns a future on its return value.  <a href="#a1723f2592299a9bf4ac9e9557929cf52">More...</a><br/></td></tr>
<tr class="separator:a1723f2592299a9bf4ac9e9557929cf52 inherit pro_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d6309517ea11b6d646e787865c000a inherit pro_methods_class_service_dispatcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#a92d6309517ea11b6d646e787865c000a">run</a> ()</td></tr>
<tr class="memdesc:a92d6309517ea11b6d646e787865c000a inherit pro_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs underlying boost asio io_service.  <a href="#a92d6309517ea11b6d646e787865c000a">More...</a><br/></td></tr>
<tr class="separator:a92d6309517ea11b6d646e787865c000a inherit pro_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ad1909afe414cd27e21c8cdd214c6c inherit pro_methods_class_service_dispatcher"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ad1909afe414cd27e21c8cdd214c6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#ad8ad1909afe414cd27e21c8cdd214c6c">resetWork</a> ()</td></tr>
<tr class="memdesc:ad8ad1909afe414cd27e21c8cdd214c6c inherit pro_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops queued functions. <br/></td></tr>
<tr class="separator:ad8ad1909afe414cd27e21c8cdd214c6c inherit pro_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf54f65ee49a65d344581078d0a61b6 inherit pro_methods_class_service_dispatcher"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf54f65ee49a65d344581078d0a61b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_service_dispatcher.html#a7bf54f65ee49a65d344581078d0a61b6">stopService</a> ()</td></tr>
<tr class="memdesc:a7bf54f65ee49a65d344581078d0a61b6 inherit pro_methods_class_service_dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops underlying service. <br/></td></tr>
<tr class="separator:a7bf54f65ee49a65d344581078d0a61b6 inherit pro_methods_class_service_dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Proxy for transporting AbstractGamePlayer events between threads. </p>
<p>As the <a class="el" href="class_game_logic.html" title="GameLogic implementation for a game of chess with observers. ">GameLogic</a> and other game components run on different threads it is essential to safely transport game events between them. Without any additional precautions AbstractGamePlayer implementations will have their handlers called on the <a class="el" href="class_game_logic.html" title="GameLogic implementation for a game of chess with observers. ">GameLogic</a> thread they are registered on with all implied thread safety concerns.</p>
<p>This proxy will serialize calls coming in from the game logic in a thread-safe way and replay them once its poll method is called in the customers thread. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a37c5c3e5d60e074a34570748b0b2a8b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::future&lt;<a class="el" href="class_turn.html">Turn</a>&gt; PlayerDispatcherProxy::doMakeTurn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_game_state.html">GameState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asks the player to make his turn. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not block. It is to return immediatly. The players turn is to be set on the returned future. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The game logic can abort its request for a player to make his turn using the doAbortTurn function at any time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current state of the game. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to the turn to make. </dd></dl>

<p>Implements <a class="el" href="class_abstract_player.html#a4954d2cc3b71d352188c863bb3d1e176">AbstractPlayer</a>.</p>

</div>
</div>
<a class="anchor" id="a4aae031f975e7c90fd80eb5e34540757"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onGameOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_game_state.html">GameState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlayerColor&#160;</td>
          <td class="paramname"><em>winner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a game started with onGameStart is over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>State on game over. </td></tr>
    <tr><td class="paramname">winner</td><td>Winner of the game. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_abstract_game_observer.html#ac24e139ff56d25fb7e77afdfb35fab5c">AbstractGameObserver</a>.</p>

</div>
</div>
<a class="anchor" id="a4331a5225da27c3519faf665a15618f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onGameStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_game_state.html">GameState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_game_configuration.html">GameConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the game starts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="class_game_state.html">GameState</a> on game start. </td></tr>
    <tr><td class="paramname">config</td><td>Valid <a class="el" href="class_game_configuration.html" title="Class for holding game configuration parameters. ">GameConfiguration</a> for this game. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_abstract_game_observer.html#a34fd2b4c53d3beb7c6bb3edebe185150">AbstractGameObserver</a>.</p>

</div>
</div>
<a class="anchor" id="a69147934e21adbbcf49ac0759a5bcd16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onSetColor </td>
          <td>(</td>
          <td class="paramtype">PlayerColor&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies that player what color he will be playing. Called before onGameStart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color the player has. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_abstract_player.html#a330465dd29cbd703563c89cdb48e895c">AbstractPlayer</a>.</p>

</div>
</div>
<a class="anchor" id="ad391616bbb56762ddb05460ce11f96ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onTurnEnd </td>
          <td>(</td>
          <td class="paramtype">PlayerColor&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_turn.html">Turn</a>&#160;</td>
          <td class="paramname"><em>turn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_game_state.html">GameState</a>&#160;</td>
          <td class="paramname"><em>newState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called if a player ended its turn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">who</td><td>Color of the player doing the turn. </td></tr>
    <tr><td class="paramname">turn</td><td><a class="el" href="class_turn.html">Turn</a> the player decided on. </td></tr>
    <tr><td class="paramname">newState</td><td>State after the player performed the turn. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_abstract_game_observer.html#afc2f078de79701a8cd77ce733459cf6c">AbstractGameObserver</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2da2b5609de70f20b44c1c8aacb1c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onTurnStart </td>
          <td>(</td>
          <td class="paramtype">PlayerColor&#160;</td>
          <td class="paramname"><em>who</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called if a player is asked to perform a turn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">who</td><td>Color of the player doing the turn. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_abstract_game_observer.html#a64dd519a6445dc104e7387b394c0286e">AbstractGameObserver</a>.</p>

</div>
</div>
<a class="anchor" id="aec9b69ba6adc27db4f08445fdacfdcb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PlayerDispatcherProxy::onTurnTimeout </td>
          <td>(</td>
          <td class="paramtype">PlayerColor&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called if a players turn is aborted due to timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">who</td><td>Color of the player who got interrupted. </td></tr>
    <tr><td class="paramname">timeout</td><td>Length of the time limit that got violated. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_abstract_game_observer.html#a74ba4cdca13bb0227722beeeebfd6e12">AbstractGameObserver</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>S:/dev/3dchess/src/logic/threading/<a class="el" href="_player_dispatcher_proxy_8h_source.html">PlayerDispatcherProxy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 6 2014 23:38:46 for 3dchess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
